package me.gabryon.second_part.job_scheduler;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public abstract class JobSchedulerStrategy<K, V> {
    
    /***
     * Generates a stream of jobs.
     * @return 
     */
    abstract protected Stream<AJob<K, V>> emit();
    
    /***
     * Executes the jobs received from emit by invoking execute on
     * them, and returns a single stream of key/value pairs obtained by 
     * concatenating the output of the jobs.Since the `compute` method is a 
     * frozen spot it cannot be overridden, so the method is qualified with the final attribute.
     * @param emitted A stream of jobs to be computed by the method. This stream
     *                is generated by the `emit` method.
     * @return 
     */
    public final Stream<Pair<K, V>> compute(Stream<AJob<K, V>> emitted) {
        return emitted.flatMap((job) -> job.execute());
    }
    
    /***
     * Takes as input the output of compute and groups all the pairs with
     * the same keys in a single pair, having the same key and the list of all values.
     * Since the `collect` method is a frozen spot it cannot be overridden,
       so, the method is qualified with the final attribute.
     * @param computed A stream of computed jobs to be collected by the method. 
     *                 This parameter is the `compute` result method.
     * @return 
     */
    protected final Stream<Pair<K, List<V>>> collect(Stream<Pair<K, V>> computed) {        
        var map = computed.collect(
                Collectors.groupingBy(
                        Pair::getKey, Collectors.mapping(
                                Pair::getValue, Collectors.toList()
                        )
                )
        );
        return map.entrySet().stream().map(entry -> new Pair(entry.getKey(), entry.getValue()));
    }
    
    /***
     * Prints the result of collect in a convenient way.
     * @param jobs A stream contained collectd results.
     */
    abstract protected void output(Stream<Pair<K, List<V>>> jobs);
}
